/**
 * Go SDK Generator
 *
 * Generates a complete Go SDK with structs, interfaces, and idiomatic patterns.
 *
 * @module sdk-generator/go
 */

import type {
  SDKConfig,
  GoSDKConfig,
  GeneratedFiles,
  ParsedNoun,
  ParsedField,
} from './types'

// ============================================================================
// Utilities
// ============================================================================

function toPascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1)
}

function toSnakeCase(str: string): string {
  return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '')
}

function fieldTypeToGo(field: ParsedField): string {
  if (field.enumValues) {
    // In Go, we use string for enums (with constants)
    return 'string'
  }

  switch (field.type) {
    case 'string':
      return 'string'
    case 'number':
    case 'float':
      return 'float64'
    case 'integer':
      return 'int64'
    case 'boolean':
      return 'bool'
    case 'date':
    case 'datetime':
      return 'string' // ISO date string
    case 'json':
    case 'object':
      return 'map[string]interface{}'
    case 'array':
      return '[]interface{}'
    case 'markdown':
      return 'string'
    default:
      return 'string'
  }
}

function toJsonTag(name: string, optional: boolean): string {
  const omitempty = optional ? ',omitempty' : ''
  return `\`json:"${toSnakeCase(name)}${omitempty}"\``
}

// ============================================================================
// Type Definitions Generator
// ============================================================================

function generateTypes(nouns: ParsedNoun[], config: SDKConfig): string {
  const structs: string[] = []

  // Generate structs for each noun
  for (const noun of nouns) {
    // Main struct
    const fields = noun.fields.map(f => {
      const goType = fieldTypeToGo(f)
      const fieldType = f.optional ? `*${goType}` : goType
      return `\t${toPascalCase(f.name)} ${fieldType} ${toJsonTag(f.name, f.optional)}`
    }).join('\n')

    structs.push(`// ${noun.name} represents a ${noun.name.toLowerCase()} resource.
type ${noun.name} struct {
${fields}
}`)

    // Create input struct (without id)
    const createFields = noun.fields
      .filter(f => f.name !== 'id')
      .map(f => {
        const goType = fieldTypeToGo(f)
        const fieldType = f.optional ? `*${goType}` : goType
        return `\t${toPascalCase(f.name)} ${fieldType} ${toJsonTag(f.name, f.optional)}`
      }).join('\n')

    structs.push(`// ${noun.name}CreateInput is the input for creating a ${noun.name.toLowerCase()}.
type ${noun.name}CreateInput struct {
${createFields}
}`)

    // Update input struct (all fields optional)
    const updateFields = noun.fields
      .filter(f => f.name !== 'id')
      .map(f => {
        const goType = fieldTypeToGo(f)
        return `\t${toPascalCase(f.name)} *${goType} ${toJsonTag(f.name, true)}`
      }).join('\n')

    structs.push(`// ${noun.name}UpdateInput is the input for updating a ${noun.name.toLowerCase()}.
type ${noun.name}UpdateInput struct {
${updateFields}
}`)

    // Enum constants if needed
    for (const field of noun.fields) {
      if (field.enumValues) {
        const enumName = `${noun.name}${toPascalCase(field.name)}`
        const constants = field.enumValues.map(v => {
          const constName = `${enumName}${toPascalCase(v)}`
          return `\t${constName} ${enumName} = "${v}"`
        }).join('\n')

        structs.push(`// ${enumName} represents the ${field.name} field values.
type ${enumName} string

const (
${constants}
)`)
      }
    }
  }

  // Pagination types
  structs.push(`// PaginationMeta contains pagination information.
type PaginationMeta struct {
\tLimit   int  \`json:"limit"\`
\tOffset  int  \`json:"offset"\`
\tTotal   int  \`json:"total"\`
\tHasMore bool \`json:"has_more"\`
}`)

  structs.push(`// ListOptions contains options for list operations.
type ListOptions struct {
\tLimit  *int               \`json:"limit,omitempty"\`
\tOffset *int               \`json:"offset,omitempty"\`
\tCursor *string            \`json:"cursor,omitempty"\`
\tFilter map[string]interface{} \`json:"-"\`
}`)

  return `// Package ${getPackageName(config.packageName)} provides types for the ${config.packageName} SDK.
//
// Generated by SaaSkit SDK Generator
// Version: ${config.version}
package ${getPackageName(config.packageName)}

${structs.join('\n\n')}
`
}

function getPackageName(name: string): string {
  return name.replace(/-/g, '').replace(/_/g, '').toLowerCase()
}

// ============================================================================
// Errors Generator
// ============================================================================

function generateErrors(config: SDKConfig): string {
  return `// Package ${getPackageName(config.packageName)} provides error types for the SDK.
//
// Generated by SaaSkit SDK Generator
// Version: ${config.version}
package ${getPackageName(config.packageName)}

import "fmt"

// APIError is the base error type for API errors.
type APIError struct {
\tMessage    string
\tStatusCode int
\tCode       string
\tRequestID  string
\tDetails    map[string]interface{}
}

func (e *APIError) Error() string {
\treturn fmt.Sprintf("%s (status: %d, code: %s, request_id: %s)", e.Message, e.StatusCode, e.Code, e.RequestID)
}

// NotFoundError is returned when a resource is not found (404).
type NotFoundError struct {
\tAPIError
\tResource string
\tID       string
}

func NewNotFoundError(resource, id, requestID string) *NotFoundError {
\treturn &NotFoundError{
\t\tAPIError: APIError{
\t\t\tMessage:    fmt.Sprintf("%s with id '%s' not found", resource, id),
\t\t\tStatusCode: 404,
\t\t\tCode:       "NOT_FOUND",
\t\t\tRequestID:  requestID,
\t\t},
\t\tResource: resource,
\t\tID:       id,
\t}
}

// ValidationError is returned when validation fails (400).
type ValidationError struct {
\tAPIError
\tValidationErrors []ValidationFieldError
}

// ValidationFieldError represents a single field validation error.
type ValidationFieldError struct {
\tField   string \`json:"field"\`
\tMessage string \`json:"message"\`
}

func NewValidationError(message string, errors []ValidationFieldError, requestID string) *ValidationError {
\treturn &ValidationError{
\t\tAPIError: APIError{
\t\t\tMessage:    message,
\t\t\tStatusCode: 400,
\t\t\tCode:       "VALIDATION_ERROR",
\t\t\tRequestID:  requestID,
\t\t},
\t\tValidationErrors: errors,
\t}
}

// RateLimitError is returned when rate limit is exceeded (429).
type RateLimitError struct {
\tAPIError
\tRetryAfter int
}

func NewRateLimitError(retryAfter int, requestID string) *RateLimitError {
\treturn &RateLimitError{
\t\tAPIError: APIError{
\t\t\tMessage:    fmt.Sprintf("Rate limit exceeded. Retry after %d seconds", retryAfter),
\t\t\tStatusCode: 429,
\t\t\tCode:       "RATE_LIMIT_EXCEEDED",
\t\t\tRequestID:  requestID,
\t\t},
\t\tRetryAfter: retryAfter,
\t}
}

// AuthenticationError is returned when authentication fails (401).
type AuthenticationError struct {
\tAPIError
}

func NewAuthenticationError(message, requestID string) *AuthenticationError {
\treturn &AuthenticationError{
\t\tAPIError: APIError{
\t\t\tMessage:    message,
\t\t\tStatusCode: 401,
\t\t\tCode:       "AUTHENTICATION_ERROR",
\t\t\tRequestID:  requestID,
\t\t},
\t}
}

// AuthorizationError is returned when authorization fails (403).
type AuthorizationError struct {
\tAPIError
}

func NewAuthorizationError(message, requestID string) *AuthorizationError {
\treturn &AuthorizationError{
\t\tAPIError: APIError{
\t\t\tMessage:    message,
\t\t\tStatusCode: 403,
\t\t\tCode:       "AUTHORIZATION_ERROR",
\t\t\tRequestID:  requestID,
\t\t},
\t}
}

// ServerError is returned for server errors (5xx).
type ServerError struct {
\tAPIError
}

func NewServerError(message string, statusCode int, requestID string) *ServerError {
\treturn &ServerError{
\t\tAPIError: APIError{
\t\t\tMessage:    message,
\t\t\tStatusCode: statusCode,
\t\t\tCode:       "SERVER_ERROR",
\t\t\tRequestID:  requestID,
\t\t},
\t}
}
`
}

// ============================================================================
// HTTP Layer Generator
// ============================================================================

function generateHttp(config: SDKConfig): string {
  const headerName = config.auth?.headerName ?? 'Authorization'
  const headerFormat = config.auth?.type === 'header' ? '%s' : 'Bearer %s'

  return `// Package ${getPackageName(config.packageName)} provides HTTP utilities for the SDK.
//
// Generated by SaaSkit SDK Generator
// Version: ${config.version}
package ${getPackageName(config.packageName)}

import (
\t"bytes"
\t"context"
\t"encoding/json"
\t"fmt"
\t"io"
\t"math"
\t"net/http"
\t"net/url"
\t"strconv"
\t"time"
)

// HTTPConfig contains configuration for the HTTP client.
type HTTPConfig struct {
\tAPIKey     string
\tBaseURL    string
\tTimeout    time.Duration
\tMaxRetries int
}

// HTTPClient handles HTTP requests with retry logic.
type HTTPClient struct {
\tapiKey     string
\tbaseURL    string
\ttimeout    time.Duration
\tmaxRetries int
\tclient     *http.Client
}

// NewHTTPClient creates a new HTTP client.
func NewHTTPClient(config HTTPConfig) *HTTPClient {
\treturn &HTTPClient{
\t\tapiKey:     config.APIKey,
\t\tbaseURL:    config.BaseURL,
\t\ttimeout:    config.Timeout,
\t\tmaxRetries: config.MaxRetries,
\t\tclient: &http.Client{
\t\t\tTimeout: config.Timeout,
\t\t},
\t}
}

// RequestOptions contains options for an HTTP request.
type RequestOptions struct {
\tMethod  string
\tPath    string
\tBody    interface{}
\tQuery   map[string]string
\tHeaders map[string]string
}

// getBackoffDelay calculates exponential backoff delay.
func getBackoffDelay(attempt int) time.Duration {
\tdelay := time.Duration(math.Pow(2, float64(attempt))) * time.Second
\tif delay > 30*time.Second {
\t\treturn 30 * time.Second
\t}
\treturn delay
}

// Request makes an HTTP request with retry logic.
func (c *HTTPClient) Request(ctx context.Context, opts RequestOptions, result interface{}) error {
\t// Build URL
\treqURL := c.baseURL + opts.Path
\tif len(opts.Query) > 0 {
\t\tparams := url.Values{}
\t\tfor k, v := range opts.Query {
\t\t\tparams.Add(k, v)
\t\t}
\t\treqURL += "?" + params.Encode()
\t}

\tvar lastErr error
\tfor attempt := 0; attempt <= c.maxRetries; attempt++ {
\t\t// Build body
\t\tvar bodyReader io.Reader
\t\tif opts.Body != nil {
\t\t\tbodyBytes, err := json.Marshal(opts.Body)
\t\t\tif err != nil {
\t\t\t\treturn err
\t\t\t}
\t\t\tbodyReader = bytes.NewReader(bodyBytes)
\t\t}

\t\t// Create request
\t\treq, err := http.NewRequestWithContext(ctx, opts.Method, reqURL, bodyReader)
\t\tif err != nil {
\t\t\treturn err
\t\t}

\t\t// Set headers
\t\treq.Header.Set("${headerName}", fmt.Sprintf("${headerFormat}", c.apiKey))
\t\treq.Header.Set("Content-Type", "application/json")
\t\tfor k, v := range opts.Headers {
\t\t\treq.Header.Set(k, v)
\t\t}

\t\t// Execute request
\t\tresp, err := c.client.Do(req)
\t\tif err != nil {
\t\t\tlastErr = err
\t\t\tif attempt < c.maxRetries {
\t\t\t\ttime.Sleep(getBackoffDelay(attempt))
\t\t\t}
\t\t\tcontinue
\t\t}
\t\tdefer resp.Body.Close()

\t\trequestID := resp.Header.Get("X-Request-ID")
\t\tif requestID == "" {
\t\t\trequestID = "unknown"
\t\t}

\t\t// Success
\t\tif resp.StatusCode >= 200 && resp.StatusCode < 300 {
\t\t\tif resp.StatusCode == 204 {
\t\t\t\treturn nil
\t\t\t}
\t\t\tif result != nil {
\t\t\t\treturn json.NewDecoder(resp.Body).Decode(result)
\t\t\t}
\t\t\treturn nil
\t\t}

\t\t// Parse error response
\t\tvar errorBody map[string]interface{}
\t\tjson.NewDecoder(resp.Body).Decode(&errorBody)

\t\tapiErr := c.createError(resp.StatusCode, errorBody, requestID)

\t\t// Don't retry client errors (except 429)
\t\tif resp.StatusCode < 500 && resp.StatusCode != 429 {
\t\t\treturn apiErr
\t\t}

\t\t// Retry on server errors and rate limits
\t\tif resp.StatusCode == 429 {
\t\t\tretryAfter, _ := strconv.Atoi(resp.Header.Get("Retry-After"))
\t\t\tif retryAfter == 0 {
\t\t\t\tretryAfter = 60
\t\t\t}
\t\t\ttime.Sleep(time.Duration(retryAfter) * time.Second)
\t\t} else {
\t\t\ttime.Sleep(getBackoffDelay(attempt))
\t\t}
\t\tlastErr = apiErr
\t}

\tif lastErr != nil {
\t\treturn lastErr
\t}
\treturn &APIError{Message: "Request failed", StatusCode: 0, Code: "UNKNOWN_ERROR", RequestID: "unknown"}
}

func (c *HTTPClient) createError(status int, body map[string]interface{}, requestID string) error {
\tmessage := "An error occurred"
\tif m, ok := body["error"].(string); ok {
\t\tmessage = m
\t} else if m, ok := body["message"].(string); ok {
\t\tmessage = m
\t}

\tswitch status {
\tcase 400:
\t\treturn NewValidationError(message, nil, requestID)
\tcase 401:
\t\treturn NewAuthenticationError(message, requestID)
\tcase 403:
\t\treturn NewAuthorizationError(message, requestID)
\tcase 404:
\t\tresource := "Resource"
\t\tid := "unknown"
\t\tif r, ok := body["resource"].(string); ok {
\t\t\tresource = r
\t\t}
\t\tif i, ok := body["id"].(string); ok {
\t\t\tid = i
\t\t}
\t\treturn NewNotFoundError(resource, id, requestID)
\tcase 429:
\t\tretryAfter := 60
\t\tif r, ok := body["retryAfter"].(float64); ok {
\t\t\tretryAfter = int(r)
\t\t}
\t\treturn NewRateLimitError(retryAfter, requestID)
\tdefault:
\t\tif status >= 500 {
\t\t\treturn NewServerError(message, status, requestID)
\t\t}
\t\treturn &APIError{Message: message, StatusCode: status, Code: "UNKNOWN_ERROR", RequestID: requestID}
\t}
}
`
}

// ============================================================================
// Service Generator
// ============================================================================

function generateService(noun: ParsedNoun, config: SDKConfig): string {
  const resourceName = noun.pluralName
  const serviceName = `${noun.name}sService`
  const typeName = noun.name
  const pkgName = getPackageName(config.packageName)

  // Generate methods
  const methods: string[] = []

  // List response type
  methods.push(`// ${noun.name}ListResponse is the response for listing ${resourceName}.
type ${noun.name}ListResponse struct {
\tData       []${typeName}     \`json:"data"\`
\tPagination PaginationMeta \`json:"pagination"\`
}`)

  // List method
  methods.push(`// List retrieves all ${resourceName}.
func (s *${serviceName}) List(ctx context.Context, opts *ListOptions) (*${noun.name}ListResponse, error) {
\tquery := make(map[string]string)
\tif opts != nil {
\t\tif opts.Limit != nil {
\t\t\tquery["limit"] = strconv.Itoa(*opts.Limit)
\t\t}
\t\tif opts.Offset != nil {
\t\t\tquery["offset"] = strconv.Itoa(*opts.Offset)
\t\t}
\t\tif opts.Cursor != nil {
\t\t\tquery["cursor"] = *opts.Cursor
\t\t}
\t}

\tvar result ${noun.name}ListResponse
\terr := s.http.Request(ctx, RequestOptions{
\t\tMethod: "GET",
\t\tPath:   "/${resourceName}",
\t\tQuery:  query,
\t}, &result)
\tif err != nil {
\t\treturn nil, err
\t}
\treturn &result, nil
}`)

  // Get method
  methods.push(`// Get retrieves a single ${toCamelCase(typeName)} by ID.
func (s *${serviceName}) Get(ctx context.Context, id string) (*${typeName}, error) {
\tvar result ${typeName}
\terr := s.http.Request(ctx, RequestOptions{
\t\tMethod: "GET",
\t\tPath:   "/${resourceName}/" + id,
\t}, &result)
\tif err != nil {
\t\treturn nil, err
\t}
\treturn &result, nil
}`)

  // Create method
  methods.push(`// Create creates a new ${toCamelCase(typeName)}.
func (s *${serviceName}) Create(ctx context.Context, input *${typeName}CreateInput) (*${typeName}, error) {
\tvar result ${typeName}
\terr := s.http.Request(ctx, RequestOptions{
\t\tMethod: "POST",
\t\tPath:   "/${resourceName}",
\t\tBody:   input,
\t}, &result)
\tif err != nil {
\t\treturn nil, err
\t}
\treturn &result, nil
}`)

  // Update method
  methods.push(`// Update updates an existing ${toCamelCase(typeName)}.
func (s *${serviceName}) Update(ctx context.Context, id string, input *${typeName}UpdateInput) (*${typeName}, error) {
\tvar result ${typeName}
\terr := s.http.Request(ctx, RequestOptions{
\t\tMethod: "PUT",
\t\tPath:   "/${resourceName}/" + id,
\t\tBody:   input,
\t}, &result)
\tif err != nil {
\t\treturn nil, err
\t}
\treturn &result, nil
}`)

  // Delete method
  methods.push(`// Delete deletes a ${toCamelCase(typeName)}.
func (s *${serviceName}) Delete(ctx context.Context, id string) error {
\treturn s.http.Request(ctx, RequestOptions{
\t\tMethod: "DELETE",
\t\tPath:   "/${resourceName}/" + id,
\t}, nil)
}`)

  // Custom verb methods
  for (const verb of noun.verbs) {
    const verbName = toPascalCase(verb)
    methods.push(`// ${verbName} executes ${verb} on a ${toCamelCase(typeName)}.
func (s *${serviceName}) ${verbName}(ctx context.Context, id string, input map[string]interface{}) (*${typeName}, error) {
\tvar result ${typeName}
\terr := s.http.Request(ctx, RequestOptions{
\t\tMethod: "POST",
\t\tPath:   "/${resourceName}/" + id + "/${verb}",
\t\tBody:   input,
\t}, &result)
\tif err != nil {
\t\treturn nil, err
\t}
\treturn &result, nil
}`)
  }

  return `// Package ${pkgName} provides the ${noun.name}s service.
//
// Generated by SaaSkit SDK Generator
// Version: ${config.version}
package ${pkgName}

import (
\t"context"
\t"strconv"
)

// ${serviceName} handles ${resourceName} operations.
type ${serviceName} struct {
\thttp *HTTPClient
}

// new${serviceName} creates a new ${serviceName}.
func new${serviceName}(http *HTTPClient) *${serviceName} {
\treturn &${serviceName}{http: http}
}

${methods.join('\n\n')}
`
}

// ============================================================================
// Client Generator
// ============================================================================

function generateClient(nouns: ParsedNoun[], config: SDKConfig): string {
  const pkgName = getPackageName(config.packageName)

  const serviceFields = nouns.map(n => {
    return `\t${n.name}s *${n.name}sService`
  }).join('\n')

  const serviceInitializations = nouns.map(n => {
    return `\t\t${n.name}s: new${n.name}sService(httpClient),`
  }).join('\n')

  return `// Package ${pkgName} provides the main client for the ${config.packageName} SDK.
//
// Generated by SaaSkit SDK Generator
// Version: ${config.version}
package ${pkgName}

import (
\t"time"
)

const (
\tdefaultBaseURL    = "${config.baseUrl || 'https://api.example.com'}"
\tdefaultTimeout    = ${(config.timeout || 30000) / 1000} * time.Second
\tdefaultMaxRetries = ${config.maxRetries || 3}
)

// ClientConfig contains configuration for the API client.
type ClientConfig struct {
\tAPIKey     string
\tBaseURL    string
\tTimeout    time.Duration
\tMaxRetries int
}

// Client is the main API client.
type Client struct {
${serviceFields}
\thttp *HTTPClient
}

// NewClient creates a new API client.
func NewClient(config ClientConfig) *Client {
\tif config.BaseURL == "" {
\t\tconfig.BaseURL = defaultBaseURL
\t}
\tif config.Timeout == 0 {
\t\tconfig.Timeout = defaultTimeout
\t}
\tif config.MaxRetries == 0 {
\t\tconfig.MaxRetries = defaultMaxRetries
\t}

\thttpClient := NewHTTPClient(HTTPConfig{
\t\tAPIKey:     config.APIKey,
\t\tBaseURL:    config.BaseURL,
\t\tTimeout:    config.Timeout,
\t\tMaxRetries: config.MaxRetries,
\t})

\treturn &Client{
${serviceInitializations}
\t\thttp: httpClient,
\t}
}
`
}

// ============================================================================
// Package Files Generator
// ============================================================================

function generateGoMod(config: SDKConfig, goConfig?: GoSDKConfig): string {
  const modulePath = goConfig?.modulePath || `github.com/example/${config.packageName}`
  const goVersion = goConfig?.goVersion || '1.21'

  return `module ${modulePath}

go ${goVersion}
`
}

// ============================================================================
// Main Generator Function
// ============================================================================

export function generateGoFiles(
  config: SDKConfig,
  nouns: ParsedNoun[],
  goConfig?: GoSDKConfig
): GeneratedFiles {
  const files: GeneratedFiles = {}

  // Generate type definitions
  files['types.go'] = generateTypes(nouns, config)

  // Generate error types
  files['errors.go'] = generateErrors(config)

  // Generate HTTP layer
  files['http.go'] = generateHttp(config)

  // Generate service files (one per noun)
  for (const noun of nouns) {
    files[`${noun.pluralName}.go`] = generateService(noun, config)
  }

  // Generate client
  files['client.go'] = generateClient(nouns, config)

  // Generate go.mod
  files['go.mod'] = generateGoMod(config, goConfig)

  return files
}
