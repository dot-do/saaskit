/**
 * Python SDK Generator
 *
 * Generates a complete Python SDK with type hints, dataclasses, and async support.
 *
 * @module sdk-generator/python
 */

import type {
  SDKConfig,
  PythonSDKConfig,
  GeneratedFiles,
  ParsedNoun,
  ParsedField,
} from './types'

// ============================================================================
// Utilities
// ============================================================================

function toSnakeCase(str: string): string {
  return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '')
}

function toPascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

function fieldTypeToPython(field: ParsedField): string {
  if (field.enumValues) {
    return `Literal[${field.enumValues.map(v => `'${v}'`).join(', ')}]`
  }

  switch (field.type) {
    case 'string':
      return 'str'
    case 'number':
    case 'integer':
    case 'float':
      return 'float' // Use float for numbers, int for integers specifically
    case 'boolean':
      return 'bool'
    case 'date':
    case 'datetime':
      return 'str' // ISO date string
    case 'json':
    case 'object':
      return 'Dict[str, Any]'
    case 'array':
      return 'List[Any]'
    case 'markdown':
      return 'str'
    default:
      return 'str'
  }
}

// ============================================================================
// Type Definitions Generator
// ============================================================================

function generateTypes(nouns: ParsedNoun[], config: SDKConfig): string {
  const classes: string[] = []

  // Generate dataclasses for each noun
  for (const noun of nouns) {
    // Main class
    const fields = noun.fields.map(f => {
      const pyType = fieldTypeToPython(f)
      const snakeName = toSnakeCase(f.name)
      if (f.optional) {
        return `    ${snakeName}: Optional[${pyType}] = None`
      }
      return `    ${snakeName}: ${pyType}`
    }).join('\n')

    classes.push(`@dataclass
class ${noun.name}:
    """${noun.name} resource model."""
${fields}
`)

    // Create input type (without id)
    const createFields = noun.fields
      .filter(f => f.name !== 'id')
      .map(f => {
        const pyType = fieldTypeToPython(f)
        const snakeName = toSnakeCase(f.name)
        if (f.optional) {
          return `    ${snakeName}: Optional[${pyType}] = None`
        }
        return `    ${snakeName}: ${pyType}`
      }).join('\n')

    classes.push(`@dataclass
class ${noun.name}CreateInput:
    """Input for creating a ${noun.name}."""
${createFields}
`)

    // Update input type (all fields optional)
    const updateFields = noun.fields
      .filter(f => f.name !== 'id')
      .map(f => {
        const pyType = fieldTypeToPython(f)
        const snakeName = toSnakeCase(f.name)
        return `    ${snakeName}: Optional[${pyType}] = None`
      }).join('\n')

    classes.push(`@dataclass
class ${noun.name}UpdateInput:
    """Input for updating a ${noun.name}."""
${updateFields}
`)
  }

  // Pagination types
  classes.push(`@dataclass
class PaginationMeta:
    """Pagination metadata."""
    limit: int
    offset: int
    total: int
    has_more: bool
`)

  classes.push(`@dataclass
class PaginatedResponse(Generic[T]):
    """Paginated response wrapper."""
    data: List[T]
    pagination: PaginationMeta
`)

  classes.push(`@dataclass
class ListOptions:
    """Options for list operations."""
    limit: Optional[int] = None
    offset: Optional[int] = None
    cursor: Optional[str] = None
    filter: Optional[Dict[str, Any]] = None
`)

  return `"""
${config.packageName} - Type Definitions
Generated by SaaSkit SDK Generator
Version: ${config.version}
"""

from dataclasses import dataclass
from typing import Any, Dict, Generic, List, Literal, Optional, TypeVar

T = TypeVar('T')

${classes.join('\n')}
`
}

// ============================================================================
// Errors Generator
// ============================================================================

function generateErrors(config: SDKConfig): string {
  return `"""
${config.packageName} - Error Classes
Generated by SaaSkit SDK Generator
Version: ${config.version}
"""

from typing import Any, Dict, List, Optional


class APIError(Exception):
    """Base API error class."""

    def __init__(
        self,
        message: str,
        status_code: int,
        code: str,
        request_id: str,
        details: Optional[Dict[str, Any]] = None,
    ):
        super().__init__(message)
        self.message = message
        self.status_code = status_code
        self.code = code
        self.request_id = request_id
        self.details = details


class NotFoundError(APIError):
    """Resource not found error (404)."""

    def __init__(self, resource: str, id: str, request_id: str):
        super().__init__(
            f"{resource} with id '{id}' not found",
            404,
            "NOT_FOUND",
            request_id,
        )


class ValidationError(APIError):
    """Validation error (400)."""

    def __init__(
        self,
        message: str,
        validation_errors: List[Dict[str, str]],
        request_id: str,
    ):
        super().__init__(
            message,
            400,
            "VALIDATION_ERROR",
            request_id,
            {"errors": validation_errors},
        )
        self.validation_errors = validation_errors


class RateLimitError(APIError):
    """Rate limit exceeded error (429)."""

    def __init__(self, retry_after: int, request_id: str):
        super().__init__(
            f"Rate limit exceeded. Retry after {retry_after} seconds",
            429,
            "RATE_LIMIT_EXCEEDED",
            request_id,
        )
        self.retry_after = retry_after


class AuthenticationError(APIError):
    """Authentication error (401)."""

    def __init__(self, message: str, request_id: str):
        super().__init__(message, 401, "AUTHENTICATION_ERROR", request_id)


class AuthorizationError(APIError):
    """Authorization error (403)."""

    def __init__(self, message: str, request_id: str):
        super().__init__(message, 403, "AUTHORIZATION_ERROR", request_id)


class ServerError(APIError):
    """Server error (5xx)."""

    def __init__(self, message: str, status_code: int, request_id: str):
        super().__init__(message, status_code, "SERVER_ERROR", request_id)
`
}

// ============================================================================
// HTTP Layer Generator
// ============================================================================

function generateHttp(config: SDKConfig): string {
  const headerName = config.auth?.headerName ?? 'Authorization'
  const headerValuePrefix = config.auth?.type === 'header' ? '' : 'Bearer '

  return `"""
${config.packageName} - HTTP Layer
Generated by SaaSkit SDK Generator
Version: ${config.version}
"""

import time
from typing import Any, Dict, Optional
from urllib.parse import urlencode

import httpx

from .errors import (
    APIError,
    AuthenticationError,
    AuthorizationError,
    NotFoundError,
    RateLimitError,
    ServerError,
    ValidationError,
)


def _get_backoff_delay(attempt: int, base_delay: float = 1.0) -> float:
    """Calculate exponential backoff delay."""
    return min(base_delay * (2 ** attempt), 30.0)


class HttpClient:
    """HTTP client with retry logic and error handling."""

    def __init__(
        self,
        api_key: str,
        base_url: str,
        timeout: float,
        max_retries: int,
    ):
        self.api_key = api_key
        self.base_url = base_url
        self.timeout = timeout
        self.max_retries = max_retries
        self._client = httpx.Client(timeout=timeout)

    def request(
        self,
        method: str,
        path: str,
        body: Optional[Dict[str, Any]] = None,
        query: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> Any:
        """Make an HTTP request with retry logic."""
        url = f"{self.base_url}{path}"

        if query:
            filtered_query = {k: v for k, v in query.items() if v is not None}
            if filtered_query:
                url = f"{url}?{urlencode(filtered_query)}"

        request_headers = {
            "${headerName}": f"${headerValuePrefix}{self.api_key}",
            "Content-Type": "application/json",
            **(headers or {}),
        }

        last_error: Optional[Exception] = None
        for attempt in range(self.max_retries + 1):
            try:
                response = self._client.request(
                    method=method,
                    url=url,
                    headers=request_headers,
                    json=body,
                )

                request_id = response.headers.get("X-Request-ID", "unknown")

                if response.is_success:
                    if response.status_code == 204:
                        return None
                    return response.json()

                # Handle error responses
                try:
                    error_body = response.json()
                except Exception:
                    error_body = {}

                error = self._create_error(response.status_code, error_body, request_id)

                # Don't retry client errors (except 429)
                if response.status_code < 500 and response.status_code != 429:
                    raise error

                # Retry server errors and rate limits
                if response.status_code == 429:
                    retry_after = int(response.headers.get("Retry-After", "60"))
                    time.sleep(retry_after)
                else:
                    time.sleep(_get_backoff_delay(attempt))

                last_error = error

            except (httpx.TimeoutException, httpx.NetworkError) as e:
                last_error = e
                if attempt < self.max_retries:
                    time.sleep(_get_backoff_delay(attempt))

        if last_error:
            raise last_error
        raise APIError("Request failed", 0, "UNKNOWN_ERROR", "unknown")

    def _create_error(
        self, status: int, body: Dict[str, Any], request_id: str
    ) -> APIError:
        """Create appropriate error class based on status code."""
        message = body.get("error") or body.get("message") or "An error occurred"

        if status == 400:
            return ValidationError(message, body.get("details", []), request_id)
        elif status == 401:
            return AuthenticationError(message, request_id)
        elif status == 403:
            return AuthorizationError(message, request_id)
        elif status == 404:
            return NotFoundError(
                body.get("resource", "Resource"),
                body.get("id", "unknown"),
                request_id,
            )
        elif status == 429:
            return RateLimitError(body.get("retryAfter", 60), request_id)
        elif status >= 500:
            return ServerError(message, status, request_id)
        else:
            return APIError(
                message, status, body.get("code", "UNKNOWN_ERROR"), request_id
            )

    def close(self) -> None:
        """Close the HTTP client."""
        self._client.close()
`
}

// ============================================================================
// Resource Class Generator
// ============================================================================

function generateResource(noun: ParsedNoun, config: SDKConfig): string {
  const resourceName = noun.pluralName
  const snakeResource = toSnakeCase(noun.name)
  const className = `${noun.name}sResource`
  const typeName = noun.name

  // Generate CRUD methods
  const methods: string[] = []

  // List method
  methods.push(`
    def list(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        cursor: Optional[str] = None,
        filter: Optional[Dict[str, Any]] = None,
    ) -> PaginatedResponse[${typeName}]:
        """List all ${resourceName}."""
        query = {
            "limit": limit,
            "offset": offset,
            "cursor": cursor,
            **(filter or {}),
        }
        response = self._http.request("GET", "/${resourceName}", query=query)
        return PaginatedResponse(
            data=[${typeName}(**item) for item in response["data"]],
            pagination=PaginationMeta(**response["pagination"]),
        )`)

  // Iterate method (generator)
  methods.push(`
    def iterate(
        self,
        limit: int = 100,
        filter: Optional[Dict[str, Any]] = None,
    ) -> Iterator[${typeName}]:
        """Iterate over all ${resourceName} with automatic pagination."""
        offset = 0
        while True:
            response = self.list(limit=limit, offset=offset, filter=filter)
            for item in response.data:
                yield item
            if not response.pagination.has_more:
                break
            offset += limit`)

  // Get method
  methods.push(`
    def get(self, id: str) -> ${typeName}:
        """Get a single ${snakeResource} by ID."""
        response = self._http.request("GET", f"/${resourceName}/{id}")
        return ${typeName}(**response)`)

  // Create method
  methods.push(`
    def create(self, input: ${typeName}CreateInput) -> ${typeName}:
        """Create a new ${snakeResource}."""
        from dataclasses import asdict
        response = self._http.request("POST", "/${resourceName}", body=asdict(input))
        return ${typeName}(**response)`)

  // Update method
  methods.push(`
    def update(self, id: str, input: ${typeName}UpdateInput) -> ${typeName}:
        """Update an existing ${snakeResource}."""
        from dataclasses import asdict
        # Filter out None values
        body = {k: v for k, v in asdict(input).items() if v is not None}
        response = self._http.request("PUT", f"/${resourceName}/{id}", body=body)
        return ${typeName}(**response)`)

  // Delete method
  methods.push(`
    def delete(self, id: str) -> None:
        """Delete a ${snakeResource}."""
        self._http.request("DELETE", f"/${resourceName}/{id}")`)

  // Custom verb methods
  for (const verb of noun.verbs) {
    const snakeVerb = toSnakeCase(verb)
    methods.push(`
    def ${snakeVerb}(self, id: str, input: Optional[Dict[str, Any]] = None) -> ${typeName}:
        """Execute ${verb} on a ${snakeResource}."""
        response = self._http.request("POST", f"/${resourceName}/{id}/${verb}", body=input)
        return ${typeName}(**response)`)
  }

  return `"""
${config.packageName} - ${noun.name} Resource
Generated by SaaSkit SDK Generator
Version: ${config.version}
"""

from typing import Any, Dict, Iterator, Optional

from ..http import HttpClient
from ..types import ${typeName}, ${typeName}CreateInput, ${typeName}UpdateInput, PaginatedResponse, PaginationMeta


class ${className}:
    """${noun.name} resource operations."""

    def __init__(self, http: HttpClient):
        self._http = http
${methods.join('')}
`
}

// ============================================================================
// Client Class Generator
// ============================================================================

function generateClient(nouns: ParsedNoun[], config: SDKConfig): string {
  const resourceProperties = nouns.map(n => {
    const propName = toSnakeCase(n.pluralName)
    return `        self.${propName} = ${n.name}sResource(self._http)`
  }).join('\n')

  const resourceImports = nouns.map(n => {
    return `from .resources.${n.pluralName} import ${n.name}sResource`
  }).join('\n')

  return `"""
${config.packageName} - Client
Generated by SaaSkit SDK Generator
Version: ${config.version}
"""

from typing import Optional

from .http import HttpClient
${resourceImports}

DEFAULT_BASE_URL = "${config.baseUrl || 'https://api.example.com'}"
DEFAULT_TIMEOUT = ${(config.timeout || 30000) / 1000}
DEFAULT_MAX_RETRIES = ${config.maxRetries || 3}


class Client:
    """${config.packageName} API Client."""

    def __init__(
        self,
        api_key: str,
        base_url: Optional[str] = None,
        timeout: Optional[float] = None,
        max_retries: Optional[int] = None,
    ):
        """
        Initialize the API client.

        Args:
            api_key: Your API key for authentication.
            base_url: Base URL for API requests (default: ${config.baseUrl || 'https://api.example.com'}).
            timeout: Request timeout in seconds (default: ${(config.timeout || 30000) / 1000}).
            max_retries: Maximum retry attempts (default: ${config.maxRetries || 3}).
        """
        self._http = HttpClient(
            api_key=api_key,
            base_url=base_url or DEFAULT_BASE_URL,
            timeout=timeout or DEFAULT_TIMEOUT,
            max_retries=max_retries or DEFAULT_MAX_RETRIES,
        )

${resourceProperties}

    def close(self) -> None:
        """Close the client and release resources."""
        self._http.close()

    def __enter__(self) -> "Client":
        return self

    def __exit__(self, *args) -> None:
        self.close()
`
}

// ============================================================================
// Init File Generator
// ============================================================================

function generateInit(nouns: ParsedNoun[], config: SDKConfig): string {
  const typeExports = nouns.flatMap(n => [
    n.name,
    `${n.name}CreateInput`,
    `${n.name}UpdateInput`,
  ])

  return `"""
${config.packageName}
Generated by SaaSkit SDK Generator
Version: ${config.version}
"""

from .client import Client
from .errors import (
    APIError,
    AuthenticationError,
    AuthorizationError,
    NotFoundError,
    RateLimitError,
    ServerError,
    ValidationError,
)
from .types import (
${typeExports.map(t => `    ${t},`).join('\n')}
    ListOptions,
    PaginatedResponse,
    PaginationMeta,
)

__all__ = [
    "Client",
    "APIError",
    "AuthenticationError",
    "AuthorizationError",
    "NotFoundError",
    "RateLimitError",
    "ServerError",
    "ValidationError",
${typeExports.map(t => `    "${t}",`).join('\n')}
    "ListOptions",
    "PaginatedResponse",
    "PaginationMeta",
]

__version__ = "${config.version}"
`
}

// ============================================================================
// Package Files Generator
// ============================================================================

function generatePyProject(config: SDKConfig): string {
  const snakeName = config.packageName.replace(/-/g, '_')

  return `[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "${config.packageName}"
version = "${config.version}"
description = "${config.packageName} SDK - Generated by SaaSkit"
readme = "README.md"
requires-python = ">=3.8"
license = "MIT"
authors = [
    { name = "Generated by SaaSkit" },
]
dependencies = [
    "httpx>=0.24.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src"]
`
}

function generateResourcesInit(nouns: ParsedNoun[]): string {
  const imports = nouns.map(n => {
    return `from .${n.pluralName} import ${n.name}sResource`
  }).join('\n')

  const exports = nouns.map(n => `"${n.name}sResource"`).join(',\n    ')

  return `"""Resource classes."""

${imports}

__all__ = [
    ${exports},
]
`
}

// ============================================================================
// Main Generator Function
// ============================================================================

export function generatePythonFiles(
  config: SDKConfig,
  nouns: ParsedNoun[],
  pyConfig?: PythonSDKConfig
): GeneratedFiles {
  const files: GeneratedFiles = {}

  // Generate type definitions
  files['src/types.py'] = generateTypes(nouns, config)

  // Generate error classes
  files['src/errors.py'] = generateErrors(config)

  // Generate HTTP layer
  files['src/http.py'] = generateHttp(config)

  // Generate resource classes
  for (const noun of nouns) {
    files[`src/resources/${noun.pluralName}.py`] = generateResource(noun, config)
  }

  // Generate resources __init__.py
  files['src/resources/__init__.py'] = generateResourcesInit(nouns)

  // Generate client class
  files['src/client.py'] = generateClient(nouns, config)

  // Generate main __init__.py
  files['src/__init__.py'] = generateInit(nouns, config)

  // Generate package files
  files['pyproject.toml'] = generatePyProject(config)

  return files
}
