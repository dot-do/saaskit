/**
 * CLI Generator
 *
 * Generates command-line interfaces from noun/verb definitions.
 * Produces a fully functional CLI with:
 * - Authentication (login/logout)
 * - CRUD operations for each noun
 * - Custom verb commands
 * - Configuration management
 * - Shell completions (bash, zsh, fish, PowerShell)
 *
 * @module cli-generator
 *
 * @example
 * ```typescript
 * import { createCLIGenerator, generateCLI } from 'saaskit/cli-generator'
 *
 * const generator = createCLIGenerator({
 *   nouns: {
 *     User: { name: 'string', email: 'string' },
 *     Post: { title: 'string', body: 'string' },
 *   },
 *   verbs: {
 *     User: { invite: ($) => ({}) },
 *     Post: { publish: ($) => ({}) },
 *   },
 *   cliName: 'myapp',
 *   packageName: 'myapp-cli',
 *   version: '1.0.0',
 *   baseUrl: 'https://api.myapp.com',
 * })
 *
 * const cli = generator.generate()
 * // cli.files contains all generated source files
 * ```
 */

import type {
  CLIConfig,
  CLIGenerator,
  GeneratedCLI,
  CommandInfo,
  ParsedNoun,
  ParsedField,
  ShellType,
  NounsConfig,
  VerbsConfig,
} from './types'

import {
  generateLoginCommand,
  generateLogoutCommand,
  generateListCommand,
  generateGetCommand,
  generateCreateCommand,
  generateUpdateCommand,
  generateDeleteCommand,
  generateVerbCommand,
  generateNounCommandGroup,
} from './commands'

import {
  generateConfigModule,
  generateConfigCommand,
  generateOutputModule,
} from './config'

import {
  generateCompletionCommand,
  getCompletionScript,
} from './completions'

// Re-export types
export type * from './types'

// ============================================================================
// Utilities
// ============================================================================

/**
 * Convert a string to plural form (simple English rules)
 */
function pluralize(word: string): string {
  if (word.endsWith('y') && !/[aeiou]y$/i.test(word)) {
    return word.slice(0, -1) + 'ies'
  }
  if (word.endsWith('s') || word.endsWith('x') || word.endsWith('ch') || word.endsWith('sh')) {
    return word + 'es'
  }
  return word + 's'
}

/**
 * Convert PascalCase to kebab-case
 */
function toKebabCase(str: string): string {
  return str.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '')
}

/**
 * Parse a field type definition
 */
function parseFieldType(name: string, typeStr: string): ParsedField {
  const optional = typeStr.endsWith('?')
  const cleanType = optional ? typeStr.slice(0, -1) : typeStr

  // Check for relationship
  if (cleanType.startsWith('->')) {
    return {
      name,
      type: 'string', // Relations are stored as IDs
      optional,
      isRelation: true,
      relationTarget: cleanType.slice(2),
    }
  }

  // Check for enum/union type
  if (cleanType.includes('|')) {
    const values = cleanType.split('|').map(v => v.trim())
    return {
      name,
      type: 'enum',
      optional,
      isRelation: false,
      enumValues: values,
    }
  }

  // Basic types
  return {
    name,
    type: cleanType,
    optional,
    isRelation: false,
  }
}

/**
 * Parse noun schema into structured format
 */
function parseNoun(name: string, schema: Record<string, string>, verbs: string[]): ParsedNoun {
  const fields: ParsedField[] = [
    { name: 'id', type: 'string', optional: false, isRelation: false },
    ...Object.entries(schema).map(([fieldName, fieldType]) => parseFieldType(fieldName, fieldType)),
  ]

  return {
    name,
    pluralName: pluralize(name).toLowerCase(),
    cliName: toKebabCase(name),
    fields,
    verbs,
  }
}

/**
 * Parse all nouns from config
 */
function parseNouns(nouns: NounsConfig, verbs: VerbsConfig): ParsedNoun[] {
  return Object.entries(nouns).map(([name, schema]) => {
    const nounVerbs = verbs[name] ? Object.keys(verbs[name]) : []
    return parseNoun(name, schema, nounVerbs)
  })
}

// ============================================================================
// File Generators
// ============================================================================

/**
 * Generate the main CLI entry point
 */
function generateMainFile(config: CLIConfig, nouns: ParsedNoun[]): string {
  return `#!/usr/bin/env node
/**
 * ${config.cliName} CLI
 *
 * ${config.description || 'Generated by saaskit CLI generator'}
 */

import { Command } from 'commander'
import { loginCommand } from './commands/login'
import { logoutCommand } from './commands/logout'
import { configCommand } from './commands/config'
import { completionCommand } from './commands/completion'
${nouns.map(noun => `import { ${noun.cliName}Command } from './commands/${noun.cliName}'`).join('\n')}

const program = new Command()

program
  .name('${config.cliName}')
  .description('${config.description || `${config.cliName} command-line interface`}')
  .version('${config.version}')

// Authentication
program.addCommand(loginCommand)
program.addCommand(logoutCommand)

// Configuration
program.addCommand(configCommand)

// Completion
program.addCommand(completionCommand)

// Resource commands
${nouns.map(noun => `program.addCommand(${noun.cliName}Command)`).join('\n')}

// Parse and execute
program.parse()
`
}

/**
 * Generate package.json for the CLI
 */
function generatePackageJson(config: CLIConfig): string {
  const pkg = {
    name: config.packageName,
    version: config.version,
    description: config.description || `${config.cliName} command-line interface`,
    type: 'module',
    bin: {
      [config.cliName]: './dist/index.js',
    },
    files: ['dist'],
    scripts: {
      build: 'tsc',
      start: 'node dist/index.js',
      dev: 'tsc --watch',
    },
    dependencies: {
      commander: '^12.0.0',
      '@inquirer/prompts': '^7.0.0',
      open: '^10.0.0',
    },
    devDependencies: {
      '@types/node': '^22.0.0',
      typescript: '^5.7.0',
    },
    engines: {
      node: '>=18.0.0',
    },
  }

  return JSON.stringify(pkg, null, 2)
}

/**
 * Generate tsconfig.json for the CLI
 */
function generateTsConfig(): string {
  const config = {
    compilerOptions: {
      target: 'ES2022',
      module: 'NodeNext',
      moduleResolution: 'NodeNext',
      lib: ['ES2022'],
      outDir: './dist',
      rootDir: './src',
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      declaration: true,
    },
    include: ['src/**/*.ts'],
    exclude: ['node_modules', 'dist'],
  }

  return JSON.stringify(config, null, 2)
}

/**
 * Generate types file for runtime use
 */
function generateTypesFile(): string {
  return `/**
 * CLI Types
 */

export type OutputFormat = 'table' | 'json' | 'yaml' | 'csv'
`
}

// ============================================================================
// Main Generator
// ============================================================================

/**
 * Create a CLI Generator from configuration
 */
export function createCLIGenerator(config: CLIConfig): CLIGenerator {
  const parsedNouns = parseNouns(config.nouns, config.verbs)

  return {
    generate(): GeneratedCLI {
      const files: Record<string, string> = {}

      // Package files
      files['package.json'] = generatePackageJson(config)
      files['tsconfig.json'] = generateTsConfig()

      // Main entry point
      files['src/index.ts'] = generateMainFile(config, parsedNouns)

      // Types
      files['src/types.ts'] = generateTypesFile()

      // Config and output utilities
      files['src/config.ts'] = generateConfigModule(config)
      files['src/output.ts'] = generateOutputModule(config)

      // Auth commands
      files['src/commands/login.ts'] = generateLoginCommand(config)
      files['src/commands/logout.ts'] = generateLogoutCommand(config)

      // Config command
      files['src/commands/config.ts'] = generateConfigCommand(config)

      // Completion command
      files['src/commands/completion.ts'] = generateCompletionCommand(config, parsedNouns)

      // Generate commands for each noun
      for (const noun of parsedNouns) {
        const nounDir = `src/commands/${noun.cliName}`

        // CRUD commands
        files[`${nounDir}/list.ts`] = generateListCommand(noun, config)
        files[`${nounDir}/get.ts`] = generateGetCommand(noun, config)
        files[`${nounDir}/create.ts`] = generateCreateCommand(noun, config)
        files[`${nounDir}/update.ts`] = generateUpdateCommand(noun, config)
        files[`${nounDir}/delete.ts`] = generateDeleteCommand(noun, config)

        // Verb commands
        for (const verb of noun.verbs) {
          files[`${nounDir}/${verb}.ts`] = generateVerbCommand(noun, verb, config)
        }

        // Noun command group
        files[`${nounDir}/index.ts`] = generateNounCommandGroup(noun, config)
      }

      // Generate command list
      const commands = [
        'login',
        'logout',
        'config',
        'completion',
        ...parsedNouns.flatMap(noun => [
          `${noun.cliName} list`,
          `${noun.cliName} get`,
          `${noun.cliName} create`,
          `${noun.cliName} update`,
          `${noun.cliName} delete`,
          ...noun.verbs.map(verb => `${noun.cliName} ${verb}`),
        ]),
      ]

      return {
        cliName: config.cliName,
        packageName: config.packageName,
        version: config.version,
        resources: parsedNouns.map(n => n.name),
        commands,
        files,
      }
    },

    getCommands(): CommandInfo[] {
      const commands: CommandInfo[] = [
        { command: 'login', description: `Authenticate with ${config.cliName}` },
        { command: 'logout', description: 'Log out and remove credentials' },
        {
          command: 'config',
          description: 'Manage configuration',
          subcommands: [
            { command: 'get', description: 'Get configuration value(s)' },
            { command: 'set', description: 'Set a configuration value' },
            { command: 'delete', description: 'Delete a configuration value' },
            { command: 'path', description: 'Show configuration file path' },
            { command: 'reset', description: 'Reset to defaults' },
          ],
        },
        {
          command: 'completion',
          description: 'Generate shell completion script',
          args: [{ name: 'shell', description: 'Shell type (bash, zsh, fish, powershell)', required: true }],
        },
      ]

      for (const noun of parsedNouns) {
        const nounCommand: CommandInfo = {
          command: noun.cliName,
          description: `Manage ${noun.pluralName}`,
          subcommands: [
            { command: 'list', description: `List all ${noun.pluralName}` },
            { command: 'get', description: `Get a ${noun.name.toLowerCase()} by ID`, args: [{ name: 'id', description: `${noun.name} ID`, required: true }] },
            { command: 'create', description: `Create a new ${noun.name.toLowerCase()}` },
            { command: 'update', description: `Update a ${noun.name.toLowerCase()}`, args: [{ name: 'id', description: `${noun.name} ID`, required: true }] },
            { command: 'delete', description: `Delete a ${noun.name.toLowerCase()}`, args: [{ name: 'id', description: `${noun.name} ID`, required: true }] },
            ...noun.verbs.map(verb => ({
              command: verb,
              description: `${verb.charAt(0).toUpperCase() + verb.slice(1)} a ${noun.name.toLowerCase()}`,
              args: [{ name: 'id', description: `${noun.name} ID`, required: true }],
            })),
          ],
        }
        commands.push(nounCommand)
      }

      return commands
    },

    getCompletionScript(shell: ShellType): string {
      return getCompletionScript(shell, config, parsedNouns)
    },
  }
}

/**
 * Generate a CLI from configuration (convenience function)
 */
export function generateCLI(config: CLIConfig): GeneratedCLI {
  const generator = createCLIGenerator(config)
  return generator.generate()
}

// Export utilities for internal use
export { parseFieldType, parseNoun, parseNouns, pluralize, toKebabCase }
